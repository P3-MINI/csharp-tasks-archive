Wszystkie etapy znajdują się w plikach Model.cs i Scene.cs
Etapy oznaczone są komentarzem oznaczonym etykietą 'TODO:'
Wszystkie szczegóły etapu znajdują się pod sekcją 'TODO:'

Stage 1a (1pt) - Model#LoadMesh()
Wczytaj plik siatki modelu znajdujący się pod ścieżką MeshPath.
Siatka modelu składa się z listy wierzchołków i listy ścian.
Każdy wierzchołek zawiera 8 atrybutów:
- 3 liczby zmiennoprzecinkowe określające pozycję wierzchołka
- 3 liczby zmiennoprzecinkowe określające wektor normalny wierzchołka
- 2 liczby zmiennoprzecinkowe określające współrzędne tekstury wierzchołka
Ściany są trójkątami o 3 indeksach, które odpowiadają wierzchołkom z listy wierzchołków

Wczytywane pliki będą w fikcyjnym formacie .mesh:
Każda linia takiego pliku zaczyna się znakiem 'v' lub 't',
określającym czy definiowany jest wierzchołek czy trójkąt.
Jeżeli linia zaczyna się od znaku 'v', to następuje po nim 8 atrybutów wierzchołka.
Należy sparsować pozycję, wektor normalny i współrzędne tekstury tego wierzchołka,
i dodać je do odpowiedniej listy positions/normals/textures.
Jeżeli linia zaczyna się od znaku 't', to następują po nim 3 indeksy budujące trójkąt.
Należy sparsować te indeksy i dodać je do listy triangles.
Po przeczytaniu całego pliku należy stworzyć nową siatkę modelu:
Mesh = new Mesh(positions, normals, textures, triangles);

Przykładowy plik można znaleźć w Resources/duck.mesh

Stage 1b (0.5pt) - Model#LoadTexture()
Wczytaj plik tekstury modelu znajdujący się pod ścieżką TexturePath.

Wczytywane pliki będą w fikcyjnym formacie .tex:
Jest to plik w formacie binarnym.
Pierwsze cztery bajty są intem przechowującym szerokość tekstury w pikselach
Następne cztery bajty są intem przechowującym wysokość tekstury w pikselach
Następne 3 * width * height bajtów to tablica bajtów zawierająca dane tekstury,
czyli kolejno wartości w bajtach czerwonego, zielonego, niebieskiego komponentu
kolejnych pikseli z kolejnych wierszy tekstury.
Tablica bajtów w pliku jest już w dobrej kolejności.

Po przeczytaniu pliku należy stworzyć nową teksturę modelu:
Texture = new Texture(data, width, height);

Przykładowy plik można znaleźć w Resources/duck.tex

Stage 2 (1pt) - Model i Model#LoadMesh()
Stwórz klasę MeshParseException dziedziczącą po Exception.
Klasa ta powinna zawierać dwa konstruktory:
- Przyjmujący nazwę pliku (string filename), numer linii (int line),
  w której wystąpił problem oraz wiadomość (string message)
- Przyjmujący dodatkowo wyjątek który spowodował ten wyjątek (Exception innerException)
Konstruktory powinny wywołać odpowiednie konstruktory z klasy bazowej Exception
Cała wiadomość wyjątku powinna być sformatowana w następujący sposób:
$"Exception while parsing \"{filename}\"({line}): {message}"
W metodzie LoadMesh w przypadku problemów z parsowaniem wyrzucaj odpowiednie wyjątki.
Rzuć wyjątkiem w następujących sytuacjach: 
- Nieprawidłowa liczba atrybutu wierzchołka
- Nieprawidłowy format atrybut wierzchołka
- Nieprawidłowa liczba wierzchołków trójkąta
- Nieprawidłowy format indeksu trójkąta
- Nieprawidłowy znak rozpoczynający linię

Stage 3 (1.5pt) - Scene#Serialize(string)
Stwórz katalog pod podaną ścieżką
Jeżeli już istnieje to usuń wszystkie pliki które się tam znajdują
Przeiteruj po wszystkich modelach w liście Models i zserializuj je
do pliku o nazwie $"{model.Name}({i}).json" używając odpowiedniej serializacji.
Żeby zagwarantować poprawną serializację zserializuj także pola (opcja IncludeFields = true).
Nie serializuj właściwości Mesh i Texture!
Dodaj odpowiednie szczegóły implementacyjne do klasy Model.

Stage 4 (1pt) - Scene#Deserialize(string)
Zdeserializuj pod wskazaną ścieżką wszystkie pliki o rozszerzeniu .json
Pamiętaj o tym że właściwości Mesh i Texture nie zostały zserializowane.
Na wczytanych obiektach należy po zserializowaniu na nowo wczytać teksturę i siatkę.
W tym celu użyj interfejsu IJsonOnDeserialized do wywołania metod LoadMesh i LoadTexture.
Żeby zagwarantować poprawną deserializację zdeserializuj także pola (opcja IncludeFields = true).
Dodaj wszystkie zdeserializowane modele do listy modeli Models.
Dodaj odpowiednie szczegóły implementacyjne do klasy Model.
